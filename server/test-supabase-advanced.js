#!/usr/bin/env node

/**
 * Supabase È´òÁ∫ßËØäÊñ≠Âíå‰øÆÂ§çÂ∑•ÂÖ∑
 * 
 * ÂäüËÉΩÔºö
 * 1. Ê∑±Â∫¶ËØäÊñ≠ "Tenant or user not found" ÈîôËØØ
 * 2. Ëá™Âä®Ê£ÄÊµãÂíå‰øÆÂ§çËøûÊé•Â≠óÁ¨¶‰∏≤ÈóÆÈ¢ò
 * 3. ÊµãËØïÂ§öÁßçËøûÊé•ÈÖçÁΩÆ
 * 4. Êèê‰æõËØ¶ÁªÜÁöÑÊïÖÈöúÊéíÈô§Âª∫ËÆÆ
 * 
 * ‰ΩøÁî®ÊñπÊ≥ï:
 * node test-supabase-advanced.js [--fix] [--test-all]
 */

require("dotenv").config();
const { URL } = require('url');
const fs = require('fs');
const path = require('path');

// ÂëΩ‰ª§Ë°åÂèÇÊï∞
const args = process.argv.slice(2);
const shouldFix = args.includes('--fix');
const testAll = args.includes('--test-all');

console.log("=== Supabase È´òÁ∫ßËØäÊñ≠Â∑•ÂÖ∑ ===");
console.log(`Ê®°Âºè: ${shouldFix ? 'Ëá™Âä®‰øÆÂ§ç' : '‰ªÖËØäÊñ≠'}\n`);

/**
 * Supabase Âå∫ÂüüÊò†Â∞Ñ
 */
const SUPABASE_REGIONS = {
  'us-east-1': 'aws-0-us-east-1',
  'us-west-1': 'aws-0-us-west-1',
  'us-west-2': 'aws-0-us-west-2',
  'ap-southeast-1': 'aws-0-ap-southeast-1',
  'ap-northeast-1': 'aws-0-ap-northeast-1',
  'ap-northeast-2': 'aws-0-ap-northeast-2',
  'ap-south-1': 'aws-0-ap-south-1',
  'eu-west-1': 'aws-0-eu-west-1',
  'eu-west-2': 'aws-0-eu-west-2',
  'eu-central-1': 'aws-0-eu-central-1',
  'ca-central-1': 'aws-0-ca-central-1',
  'sa-east-1': 'aws-0-sa-east-1'
};

/**
 * Ê£ÄÊµã Supabase È°πÁõÆ‰ø°ÊÅØ
 */
function detectSupabaseProject(url) {
  const patterns = {
    // Direct connection: db.xxxxx.supabase.co
    direct: /db\.([a-z]+)\.supabase\.co/,
    // Pooler connection: aws-0-region.pooler.supabase.com
    pooler: /(aws-0-[a-z-]+)\.pooler\.supabase\.com/,
    // ‰ªéÁî®Êà∑ÂêçÊèêÂèñÈ°πÁõÆID: postgres.xxxxx
    username: /postgres\.([a-z]+)/
  };
  
  const result = {
    projectRef: null,
    region: null,
    connectionType: null
  };
  
  // Â∞ùËØï‰ªéURLÊèêÂèñ
  const directMatch = url.match(patterns.direct);
  if (directMatch) {
    result.projectRef = directMatch[1];
    result.connectionType = 'direct';
  }
  
  const poolerMatch = url.match(patterns.pooler);
  if (poolerMatch) {
    result.region = poolerMatch[1];
    result.connectionType = 'pooler';
  }
  
  // Â∞ùËØï‰ªéÁî®Êà∑ÂêçÊèêÂèñ
  try {
    const parsed = new URL(url);
    const usernameMatch = parsed.username.match(patterns.username);
    if (usernameMatch) {
      result.projectRef = usernameMatch[1];
    }
  } catch (e) {
    // ÂøΩÁï•Ëß£ÊûêÈîôËØØ
  }
  
  return result;
}

/**
 * ÁîüÊàêÊâÄÊúâÂèØËÉΩÁöÑËøûÊé•Â≠óÁ¨¶‰∏≤Âèò‰Ωì
 */
function generateConnectionVariants(originalUrl) {
  const variants = [];
  
  try {
    const parsed = new URL(originalUrl);
    const projectInfo = detectSupabaseProject(originalUrl);
    
    if (!projectInfo.projectRef) {
      console.log("‚ö†Ô∏è  Êó†Ê≥ïÊ£ÄÊµãÈ°πÁõÆÂºïÁî®ID");
      return variants;
    }
    
    // ÁîüÊàê‰∏çÂêåÁöÑÂØÜÁ†ÅÁºñÁ†Å
    const passwords = [
      parsed.password, // ÂéüÂßãÂØÜÁ†Å
      decodeURIComponent(parsed.password), // Ëß£Á†ÅÂêéÁöÑÂØÜÁ†Å
      encodeURIComponent(decodeURIComponent(parsed.password)) // ÈáçÊñ∞ÁºñÁ†ÅÁöÑÂØÜÁ†Å
    ];
    
    // ÁîüÊàê‰∏çÂêåÁöÑ‰∏ªÊú∫ÈÖçÁΩÆ
    const hosts = [];
    
    // Direct connection
    hosts.push({
      hostname: `db.${projectInfo.projectRef}.supabase.co`,
      port: '5432',
      type: 'direct'
    });
    
    // Pooler connections (Â∞ùËØï‰∏çÂêåÂå∫Âüü)
    Object.values(SUPABASE_REGIONS).forEach(region => {
      hosts.push({
        hostname: `${region}.pooler.supabase.com`,
        port: '6543',
        type: 'pooler',
        region: region
      });
    });
    
    // ÁîüÊàêÊâÄÊúâÁªÑÂêà
    hosts.forEach(host => {
      passwords.forEach(password => {
        const variant = {
          url: `postgresql://${parsed.username}:${password}@${host.hostname}:${host.port}${parsed.pathname}`,
          type: host.type,
          region: host.region,
          passwordEncoding: password === parsed.password ? 'original' : 'encoded'
        };
        variants.push(variant);
      });
    });
    
  } catch (error) {
    console.error("‚ùå Êó†Ê≥ïÁîüÊàêËøûÊé•Âèò‰Ωì:", error.message);
  }
  
  return variants;
}

/**
 * ÊµãËØïÂçï‰∏™ËøûÊé•ÈÖçÁΩÆ
 */
async function testSingleConnection(config, options = {}) {
  const { silent = false, timeout = 5000 } = options;
  
  if (!silent) {
    console.log(`\nÊµãËØï: ${config.type} (${config.region || 'default'})`);
  }
  
  try {
    const postgres = require("postgres");
    
    const sql = postgres(config.url, {
      ssl: 'require',
      connect_timeout: Math.floor(timeout / 1000),
      max: 1,
      idle_timeout: 0,
      max_lifetime: 60 * 2
    });
    
    // ËÆæÁΩÆË∂ÖÊó∂
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Connection timeout')), timeout)
    );
    
    // ÊµãËØïÊü•ËØ¢
    const queryPromise = sql`
      SELECT 
        current_database() as db,
        current_user as user,
        now() as time
    `.then(async (result) => {
      await sql.end();
      return result;
    });
    
    const result = await Promise.race([queryPromise, timeoutPromise]);
    
    if (!silent) {
      console.log(`‚úÖ ËøûÊé•ÊàêÂäü!`);
      console.log(`   Êï∞ÊçÆÂ∫ì: ${result[0].db}`);
      console.log(`   Áî®Êà∑: ${result[0].user}`);
    }
    
    return { success: true, config, result: result[0] };
    
  } catch (error) {
    if (!silent) {
      console.log(`‚ùå ËøûÊé•Â§±Ë¥•: ${error.message}`);
    }
    
    return { 
      success: false, 
      config, 
      error: error.message,
      errorCode: error.code
    };
  }
}

/**
 * ÊâπÈáèÊµãËØïËøûÊé•
 */
async function testMultipleConnections(variants) {
  console.log(`\nüîÑ ÊµãËØï ${variants.length} ‰∏™ËøûÊé•ÈÖçÁΩÆ...`);
  
  const results = [];
  const successfulConfigs = [];
  
  // ‰ΩøÁî® Promise.allSettled Âπ∂Ë°åÊµãËØï
  const promises = variants.map(variant => 
    testSingleConnection(variant, { silent: true, timeout: 3000 })
  );
  
  const settled = await Promise.allSettled(promises);
  
  settled.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      results.push(result.value);
      if (result.value.success) {
        successfulConfigs.push(result.value);
      }
    }
  });
  
  // ÊòæÁ§∫ÁªìÊûúÊëòË¶Å
  console.log(`\nüìä ÊµãËØïÁªìÊûú:`);
  console.log(`   ÊàêÂäü: ${successfulConfigs.length}`);
  console.log(`   Â§±Ë¥•: ${results.length - successfulConfigs.length}`);
  
  if (successfulConfigs.length > 0) {
    console.log(`\n‚úÖ ÂèØÁî®ÁöÑËøûÊé•ÈÖçÁΩÆ:`);
    successfulConfigs.forEach((config, index) => {
      console.log(`\n${index + 1}. ${config.config.type} (${config.config.region || 'default'})`);
      console.log(`   ÂØÜÁ†ÅÁºñÁ†Å: ${config.config.passwordEncoding}`);
      console.log(`   ËøûÊé•Â≠óÁ¨¶‰∏≤: ${config.config.url.substring(0, 60)}...`);
    });
    
    return successfulConfigs[0].config.url;
  }
  
  // ÂàÜÊûêÂ§±Ë¥•ÂéüÂõ†
  console.log(`\n‚ùå ÊâÄÊúâËøûÊé•ÈÉΩÂ§±Ë¥•‰∫Ü„ÄÇÈîôËØØÂàÜÊûê:`);
  const errorGroups = {};
  results.filter(r => !r.success).forEach(r => {
    const key = r.error;
    if (!errorGroups[key]) {
      errorGroups[key] = [];
    }
    errorGroups[key].push(r);
  });
  
  Object.entries(errorGroups).forEach(([error, configs]) => {
    console.log(`\n"${error}": ${configs.length} Ê¨°`);
    if (configs.length <= 3) {
      configs.forEach(c => {
        console.log(`   - ${c.config.type} (${c.config.region || 'default'})`);
      });
    }
  });
  
  return null;
}

/**
 * ‰øÆÂ§ç .env Êñá‰ª∂
 */
function updateEnvFile(newUrl) {
  const envPath = path.join(process.cwd(), '.env');
  
  try {
    let content = '';
    if (fs.existsSync(envPath)) {
      content = fs.readFileSync(envPath, 'utf8');
    }
    
    // Êõ¥Êñ∞ÊàñÊ∑ªÂä† DATABASE_URL
    const lines = content.split('\n');
    let updated = false;
    
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith('DATABASE_URL=') || lines[i].startsWith('SUPABASE_DATABASE_URL=')) {
        lines[i] = `DATABASE_URL=${newUrl}`;
        updated = true;
        break;
      }
    }
    
    if (!updated) {
      lines.push(`DATABASE_URL=${newUrl}`);
    }
    
    fs.writeFileSync(envPath, lines.join('\n'));
    console.log(`\n‚úÖ Â∑≤Êõ¥Êñ∞ .env Êñá‰ª∂`);
    
  } catch (error) {
    console.error(`\n‚ùå Êó†Ê≥ïÊõ¥Êñ∞ .env Êñá‰ª∂: ${error.message}`);
  }
}

/**
 * ‰∏ªËØäÊñ≠ÂáΩÊï∞
 */
async function diagnose() {
  // 1. Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáè
  console.log("1Ô∏è‚É£  Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáè...");
  const databaseUrl = process.env.DATABASE_URL || process.env.SUPABASE_DATABASE_URL;
  
  if (!databaseUrl) {
    console.error("‚ùå Êú™ÊâæÂà∞ DATABASE_URL Êàñ SUPABASE_DATABASE_URL");
    console.log("\nËß£ÂÜ≥ÊñπÊ°à:");
    console.log("1. ÂàõÂª∫ .env Êñá‰ª∂");
    console.log("2. Ê∑ªÂä†: DATABASE_URL=‰Ω†ÁöÑSupabaseËøûÊé•Â≠óÁ¨¶‰∏≤");
    return;
  }
  
  console.log("‚úÖ ÊâæÂà∞Êï∞ÊçÆÂ∫ìURL");
  
  // 2. Ê£ÄÊµãÈ°πÁõÆ‰ø°ÊÅØ
  console.log("\n2Ô∏è‚É£  Ê£ÄÊµã Supabase È°πÁõÆ‰ø°ÊÅØ...");
  const projectInfo = detectSupabaseProject(databaseUrl);
  
  if (projectInfo.projectRef) {
    console.log(`‚úÖ È°πÁõÆÂºïÁî®: ${projectInfo.projectRef}`);
  }
  if (projectInfo.region) {
    console.log(`‚úÖ Âå∫Âüü: ${projectInfo.region}`);
  }
  if (projectInfo.connectionType) {
    console.log(`‚úÖ ËøûÊé•Á±ªÂûã: ${projectInfo.connectionType}`);
  }
  
  // 3. ÊµãËØïÂΩìÂâçËøûÊé•
  console.log("\n3Ô∏è‚É£  ÊµãËØïÂΩìÂâçËøûÊé•...");
  const currentTest = await testSingleConnection({ url: databaseUrl, type: 'current' });
  
  if (currentTest.success) {
    console.log("\nüéâ ÂΩìÂâçËøûÊé•Ê≠£Â∏∏Â∑•‰Ωú!");
    return;
  }
  
  // 4. ÂàÜÊûêÈîôËØØ
  console.log("\n4Ô∏è‚É£  ÂàÜÊûêÈîôËØØÂéüÂõ†...");
  if (currentTest.error.includes('Tenant or user not found')) {
    console.log("‚ùå ÈîôËØØ: Tenant or user not found");
    console.log("\nÂèØËÉΩÁöÑÂéüÂõ†:");
    console.log("1. Áî®Êà∑ÂêçÊ†ºÂºè‰∏çÊ≠£Á°ÆÔºàÂøÖÈ°ªÊòØ postgres.xxxxxÔºâ");
    console.log("2. ‰ΩøÁî®‰∫ÜÈîôËØØÁöÑËøûÊé•Á±ªÂûã");
    console.log("3. È°πÁõÆÂèØËÉΩÂ∑≤Ë¢´Âà†Èô§ÊàñÊöÇÂÅú");
  }
  
  // 5. Â∞ùËØïËá™Âä®‰øÆÂ§ç
  if (testAll || shouldFix) {
    console.log("\n5Ô∏è‚É£  Â∞ùËØïËá™Âä®‰øÆÂ§ç...");
    const variants = generateConnectionVariants(databaseUrl);
    
    if (variants.length > 0) {
      const workingUrl = await testMultipleConnections(variants);
      
      if (workingUrl && shouldFix) {
        console.log("\nüîß Â∫îÁî®‰øÆÂ§ç...");
        updateEnvFile(workingUrl);
        console.log("\n‚úÖ ‰øÆÂ§çÂÆåÊàê! ËØ∑ÈáçÂêØÂ∫îÁî®‰ª•‰ΩøÁî®Êñ∞ÁöÑËøûÊé•Â≠óÁ¨¶‰∏≤„ÄÇ");
      } else if (workingUrl) {
        console.log("\nüí° ÊâæÂà∞ÂèØÁî®ÁöÑËøûÊé•! ‰ΩøÁî® --fix ÂèÇÊï∞Êù•Ëá™Âä®Êõ¥Êñ∞ .env Êñá‰ª∂„ÄÇ");
      }
    }
  }
  
  // 6. È¢ùÂ§ñÂª∫ËÆÆ
  console.log("\n6Ô∏è‚É£  ÊïÖÈöúÊéíÈô§Âª∫ËÆÆ:");
  console.log("\nÂ¶ÇÊûúÈóÆÈ¢ò‰ªçÁÑ∂Â≠òÂú®ÔºåËØ∑Â∞ùËØï:");
  console.log("1. ÁôªÂΩï Supabase Dashboard Á°ÆËÆ§È°πÁõÆÁä∂ÊÄÅ");
  console.log("2. ÈáçÁΩÆÊï∞ÊçÆÂ∫ìÂØÜÁ†ÅÔºà‰ΩøÁî®ÁÆÄÂçïÂØÜÁ†ÅÔºåÈÅøÂÖçÁâπÊÆäÂ≠óÁ¨¶Ôºâ");
  console.log("3. ‰ªé Dashboard Â§çÂà∂ÊúÄÊñ∞ÁöÑ Session Pooler ËøûÊé•Â≠óÁ¨¶‰∏≤");
  console.log("4. Á°Æ‰øùÈ°πÁõÆÊú™Ë∂ÖÂá∫ÂÖçË¥πÂ±ÇÈôêÂà∂");
  console.log("5. ËÄÉËôëÂàõÂª∫Êñ∞ÁöÑ Supabase È°πÁõÆ");
  console.log("\nÂÖ∂‰ªñÈÄâÈ°π:");
  console.log("- ‰ΩøÁî® Railway PostgreSQL Êèí‰ª∂");
  console.log("- ‰ΩøÁî® Neon.tech (Âè¶‰∏Ä‰∏™ PostgreSQL ÊúçÂä°)");
  console.log("- ‰ΩøÁî®Êú¨Âú∞ PostgreSQL ËøõË°åÂºÄÂèë");
}

// ËøêË°åËØäÊñ≠
diagnose().catch(console.error);